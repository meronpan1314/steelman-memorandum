---
title: DBにおけるハードパースとソフトパース
date: "2026-02-04"
---

## 1. 概要

本ドキュメントでは、DB（主にOracle）における**ハードパース**と**ソフトパース**の違いを整理し、
なぜSQLの「完全一致」が重要なのか、また PostgreSQL / MySQL など他DBとの違いについて説明する。

---

## 2. パースとは何か

DBがSQLを受け取った際、以下の処理が行われる。

1. 構文解析（Syntax Check）
2. オブジェクト解決（表・列の存在確認）
3. 権限チェック
4. 最適化（実行計画生成）

この **1〜4 をまとめて「パース」**と呼ぶ。

---

## 3. ハードパース（Hard Parse）

### 定義

共有プール（Library Cache）に**一致するSQLカーソルが存在しない場合**に、
SQLを新規解析し、実行計画を生成する処理。

### 特徴

* 実行計画を新規作成
* CPUコストが高い
* Library Cache のラッチ競合を起こしやすい

### 発生しやすい例

```sql
SELECT * FROM emp WHERE empno = 100;
SELECT * FROM emp WHERE empno = 101;
```

※ リテラルが異なるため、文字列が一致せず**毎回ハードパース**

### 問題点

* 高トラフィック環境では性能劣化の主要因
* DBスケールの阻害要因

---

## 4. ソフトパース（Soft Parse）

### 定義

共有プールに存在する**既存のSQLカーソルおよび実行計画を再利用**して実行する処理。

### 特徴

* 実行計画の再利用
* CPU負荷が極小
* DBが最も好む実行形態

### 典型例（バインド変数）

```sql
SELECT * FROM emp WHERE empno = :empno;
```

### 補足

「過去の実行履歴を使う」という表現は概ね正しいが、
厳密には**ログではなくメモリ上のキャッシュ（共有プール）を参照**している。

---

## 5. なぜ「完全一致」が必要なのか

### OracleにおけるSQL識別

Oracleは、**SQL文を文字列として比較**し、完全一致した場合のみ
同一カーソルとして扱う。

#### 完全一致に含まれる要素

* SQL全文
* 大文字・小文字
* 空白・改行
* コメント
* リテラル値

```sql
SELECT * FROM emp WHERE empno = :empno;
select * from emp where empno = :empno;
```

→ 人間的には同じだが **Oracle的には別SQL**

### 設計上の理由

* 高速に一致判定するため（文字列比較）
* 曖昧解釈を排除し、決定論的に動作させるため

### その結果

* SQLを揃えないとハードパースが増加
* バインド変数が必須設計要素となる

---

## 6. Oracle以外のDBとの違い

※ ここでは代表的な RDBMS である PostgreSQL / MySQL / Microsoft SQL Server（T-SQL）との違いを整理する。

### PostgreSQL

* 実行計画キャッシュは**限定的**
* プロトコルレベルで Prepared Statement を使った場合のみ再利用
* 通常のSQL発行では毎回パースされるケースが多い

特徴：

* ハードパース/ソフトパースの概念がOracleほど前面に出ない
* プランキャッシュ問題よりI/Oやロック設計が重要

---

### MySQL

* パーサは比較的軽量
* 過去の Query Cache（※廃止済）は結果キャッシュであり、実行計画ではない
* Prepared Statement 利用時のみ類似の再利用が発生

特徴：

* Oracleほどパースコストが支配的になりにくい
* SQLキャッシュよりインデックス設計が支配的

---

### Microsoft SQL Server（T-SQL）

* **実行計画キャッシュ（Plan Cache）** を強力に活用
* SQL文字列単位で実行計画をキャッシュ
* パラメータ化により再利用性が大きく向上

#### 特徴

* Oracleと同様に「再利用前提」の思想
* ただし Oracle ほど厳密な完全一致ではなく、
  **自動パラメータ化（Simple / Forced Parameterization）** が存在

#### パラメータ化の挙動

* Simple Parameterization

  * SQL Server が自動的に一部リテラルをパラメータ化
* Forced Parameterization

  * DB単位で強制的にパラメータ化（副作用に注意）

```sql
SELECT * FROM emp WHERE empno = 100;
SELECT * FROM emp WHERE empno = 101;
```

→ 条件次第では **同一実行計画が再利用される**

#### 注意点

* パラメータスニッフィング問題

  * 初回実行時の値に引きずられた実行計画がキャッシュされる
* 再利用性と最適性のトレードオフが発生

---

## 7. DBごとの思想の違いまとめ

| DB         | 実行計画再利用 | 完全一致の重要性          | 設計上の注意点              |
| ---------- | ------- | ----------------- | -------------------- |
| Oracle     | 非常に強い   | 非常に高い             | バインド変数必須             |
| PostgreSQL | 限定的     | 中                 | Prepared Statement前提 |
| MySQL      | 弱い      | 低                 | インデックス設計重視           |
| SQL Server | 強い      | 高（Oracleほど厳密ではない） | パラメータ化とプランキャッシュ管理    |

---

## 8. 設計指針（共通）

* Oracle

  * SQLの完全一致を強制
  * バインド変数を標準化

* PostgreSQL / MySQL

  * ORMやドライバの挙動を理解
  * 無駄なSQL生成を抑制

---

## 9. まとめ

* ハードパースは「新規作成」、ソフトパースは「再利用」
* Oracleでは完全一致が再利用条件
* 他DBでは同概念は弱く、設計上の重心が異なる

DBごとの思想を理解した上で、適切なSQL設計を行うことが重要である。
